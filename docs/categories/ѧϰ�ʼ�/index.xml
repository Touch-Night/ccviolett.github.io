<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>学习笔记 on 罗潇阳的博客</title>
    <link>http://ccviolett.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 学习笔记 on 罗潇阳的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 04 Apr 2022 07:56:27 +0800</lastBuildDate><atom:link href="http://ccviolett.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>学习笔记 | 逻辑学导论</title>
      <link>http://ccviolett.github.io/posts/38-lesson-logic/</link>
      <pubDate>Mon, 04 Apr 2022 07:56:27 +0800</pubDate>
      
      <guid>http://ccviolett.github.io/posts/38-lesson-logic/</guid>
      <description>直言命题 文恩图 欧拉图 周延性 对当方阵（逻辑方阵） 对当关系论证   1. 引论：走进逻辑学  1.1 逻辑学是什么 1.2 逻辑与法律：普罗泰戈拉悖论 1.3 逻辑学的功能和研究范围 1.4 认识“非西方逻辑”   2. 论证  2.1 论证的关键概念 2.2 命题、陈述与语句 2.3 经验命题与必然命题 2.4 论证的含义与类型     直言命题    每一个直言命题都由四个要素构成：量项-主项-联项-谓项
如：量项(所有) 主项(艺术家) 联项(都是) 谓项(人)
直言命题的四种形式：
 A：所有 S 都是 P E：所有 S 都不是 P I：有些 S 是 P O：有些 S 不是 P  直言命题的量：根据直言命题的量项，分为 全称命题 与 特称命题。</description>
    </item>
    
    <item>
      <title>学习笔记 | 知识论导论：我们能知道什么？</title>
      <link>http://ccviolett.github.io/posts/37-lesson-epistemology/</link>
      <pubDate>Mon, 04 Apr 2022 07:55:58 +0800</pubDate>
      
      <guid>http://ccviolett.github.io/posts/37-lesson-epistemology/</guid>
      <description></description>
    </item>
    
    <item>
      <title>学习笔记 | 意义生活：符号学导论</title>
      <link>http://ccviolett.github.io/posts/36-lesson-semiotics/</link>
      <pubDate>Mon, 04 Apr 2022 07:54:42 +0800</pubDate>
      
      <guid>http://ccviolett.github.io/posts/36-lesson-semiotics/</guid>
      <description></description>
    </item>
    
    <item>
      <title>学习笔记 | 宋崇导演教你拍摄微电影</title>
      <link>http://ccviolett.github.io/posts/35-lesson-microfilm/</link>
      <pubDate>Mon, 04 Apr 2022 07:54:06 +0800</pubDate>
      
      <guid>http://ccviolett.github.io/posts/35-lesson-microfilm/</guid>
      <description>顾长卫《龙头》    模糊的语言拥有丰富的外延，精确的语言只有简单的内涵。
作家电影：不是用来讲故事的，有许多的符号，许多的象征、对比
白猫、黑猫的对比
捡破烂的老人穿过城市形成鲜明的反差
举重象征着生活的压力，无法平衡，但是还是在继续尝试
微电影创作规律    《爬树》
伟大的作品往往是最简单的，想要过于复杂的剧情往往会走上歧途
《绝世高手》
 必须有一个好故事，起承转合，头尾短，发展快，高潮迭起。 悬念和节奏，防止大场面和仪式表达、渲染。 人物突出、要少，尽量 3 人 细节要深刻、生动、精彩 必须使用蒙太奇打破时空、快速大量表达信息  微电影中不能有主题曲
三同镜头    电影拍摄过程中要避免三同镜头，分别是：同角度、同景别、同内容
角度：两个镜头之间至少相差 20 度，否则会显得很平
景别：两级镜头跳转，全景与特写的交替最让人舒服。但是不要一味使用特写镜头。
内容：两个镜头不要表现同样的内容
微电影关键词    本土思考、国际视野、中国手法</description>
    </item>
    
    <item>
      <title>学习笔记 | C&#43;&#43; 程序设计</title>
      <link>http://ccviolett.github.io/posts/28-lesson-cpp/</link>
      <pubDate>Wed, 23 Mar 2022 20:46:47 +0800</pubDate>
      
      <guid>http://ccviolett.github.io/posts/28-lesson-cpp/</guid>
      <description>构造函数与析构函数执行顺序    当一个有成员对象的派生类对象时，各构造函数体的执行次序为 (C)。
 (A) 派生类、成员对象类、基类； (B) 成员对象类、基类、派生类； (C) 基类、成员对象类、派生类； (D) 基类、派生类、成员对象类  在新建对象时
 首先会按照继承顺序（从左到右）执行基类构造函数 然后会按照声明顺序（从上到下）执行成员对象类构造函数 最后执行当前类的构造函数  成员对象构造函数的调用顺序和初始化列表中顺序无关，只和声明顺序有关。
析构函数执行顺序正好相反，先构造后析构，后构造先析构。
#include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; class A { public: A() { cout &amp;lt;&amp;lt; &amp;#34;A&amp;#34;; } ~A() { cout &amp;lt;&amp;lt; &amp;#34;a&amp;#34;; } }; class B { public: B() { cout &amp;lt;&amp;lt; &amp;#34;B&amp;#34;; } ~B() { cout &amp;lt;&amp;lt; &amp;#34;b&amp;#34;; } }; class D { public: D() { cout &amp;lt;&amp;lt; &amp;#34;D&amp;#34;; } ~D() { cout &amp;lt;&amp;lt; &amp;#34;d&amp;#34;; } }; class E { public: E() { cout &amp;lt;&amp;lt; &amp;#34;E&amp;#34;; } ~E() { cout &amp;lt;&amp;lt; &amp;#34;e&amp;#34;; } }; class F { public: F() { cout &amp;lt;&amp;lt; &amp;#34;F&amp;#34;; } ~F() { cout &amp;lt;&amp;lt; &amp;#34;f&amp;#34;; } }; class C : public A, public E { D d; B b; public: C(): b(), f(), d() { cout &amp;lt;&amp;lt; &amp;#34;C&amp;#34;; } ~C() { cout &amp;lt;&amp;lt; &amp;#34;c&amp;#34;; } F f; }; int main() { C *c = new C(); delete c; return 0; } 当上述程序运行时，输出的结果为 &amp;ldquo;AEDBFCcfbdea&amp;rdquo;</description>
    </item>
    
  </channel>
</rss>
