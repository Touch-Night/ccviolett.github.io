<!DOCTYPE html>
<html lang="zh-cn">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="zh-cn">
    <meta name="color-scheme" content="light dark">

    

    <meta name="author" content="罗潇阳">
    <meta name="description" content="大杂烩    包含
 ST表 树状数组 线段树 LCT 按秩压缩并查集 路径压缩并查集 Dijsktra 单源最短路 Kruskal 最小生成树 Tarjan 缩点 点分治 树链剖分 平衡树 可持久化数组 可持久化线段树 线性基 矩阵 字符串哈希 Manacher KMP  typedef int readtype;  /* Header {{{ */ #include &lt;bits/stdc&#43;&#43;.h&gt;using namespace std;  template&lt;typename type&gt; type beMin(type &amp;a, type b) { return a = (a &lt; b ? a : b); } template&lt;typename type&gt; type beMax(type &amp;a, type b) { return a = (a &gt; b ?">
    <meta name="keywords" content="博客,开发者,个人">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="我的 ACM 模板"/>
<meta name="twitter:description" content="大杂烩    包含
 ST表 树状数组 线段树 LCT 按秩压缩并查集 路径压缩并查集 Dijsktra 单源最短路 Kruskal 最小生成树 Tarjan 缩点 点分治 树链剖分 平衡树 可持久化数组 可持久化线段树 线性基 矩阵 字符串哈希 Manacher KMP  typedef int readtype;  /* Header {{{ */ #include &lt;bits/stdc&#43;&#43;.h&gt;using namespace std;  template&lt;typename type&gt; type beMin(type &amp;a, type b) { return a = (a &lt; b ? a : b); } template&lt;typename type&gt; type beMax(type &amp;a, type b) { return a = (a &gt; b ?"/>

    <meta property="og:title" content="我的 ACM 模板" />
<meta property="og:description" content="大杂烩    包含
 ST表 树状数组 线段树 LCT 按秩压缩并查集 路径压缩并查集 Dijsktra 单源最短路 Kruskal 最小生成树 Tarjan 缩点 点分治 树链剖分 平衡树 可持久化数组 可持久化线段树 线性基 矩阵 字符串哈希 Manacher KMP  typedef int readtype;  /* Header {{{ */ #include &lt;bits/stdc&#43;&#43;.h&gt;using namespace std;  template&lt;typename type&gt; type beMin(type &amp;a, type b) { return a = (a &lt; b ? a : b); } template&lt;typename type&gt; type beMax(type &amp;a, type b) { return a = (a &gt; b ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://ccviolett.github.io/posts/acmtemplate/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-09T11:30:03+08:00" />
<meta property="article:modified_time" content="2022-07-09T11:30:03+08:00" />



    <title>
  我的 ACM 模板 · 罗潇阳的博客
</title>

    
      <link rel="canonical" href="http://ccviolett.github.io/posts/acmtemplate/">
    

    <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="/css/coder.min.728f45c9eaff821acb9cccdb60c81cf16be81bd890ee22cc5b5f4dbf276a082f.css" integrity="sha256-co9Fyer/ghrLnMzbYMgc8WvoG9iQ7iLMW19NvydqCC8=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="/css/coder-dark.min.aa883b9ce35a8ff4a2a5008619005175e842bb18a8a9f9cc2bbcf44dab2d91fa.css" integrity="sha256-qog7nONaj/SipQCGGQBRdehCuxioqfnMK7z0Tastkfo=" crossorigin="anonymous" media="screen" />
      
    

    

    

    <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    <meta name="generator" content="Hugo 0.99.1" />
  </head>

  
  
    
  
  <body class="preload-transitions colorscheme-auto">
    
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


    <main class="wrapper">
      <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?90bcdb8127c31d4d27ebb95576bc8474";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-228764760-1">
</script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-228764760-1');
</script>

<style>
iframe {
	width: 50vw;
	height: 30vw;
}
</style>

<nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      罗潇阳的博客
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/">首页</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">文章</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/solution/">题解</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/videos/">视频</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/contact/">联系</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">关于</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/support/">赞助</a>
            </li>
          
        
        
          
          
          
            
          
            
              
                <li class="navigation-item menu-separator">
                  <span>|</span>
                </li>
                
              
              <li class="navigation-item">
                <a href="http://ccviolett.github.io/en/">🇬🇧</a>
              </li>
            
          
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://ccviolett.github.io/posts/acmtemplate/">
              我的 ACM 模板
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime='2022-07-09T11:30:03&#43;08:00'>
                2022 年 7 月 9 日
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              阅读时间：29 分钟
            </span>
          </div>
          
          
          
        </div>
      </header>

      <div>
        
        <h2 id="大杂烩">
  大杂烩
  <a class="heading-link" href="#%e5%a4%a7%e6%9d%82%e7%83%a9">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>包含</p>
<ul>
<li>ST表</li>
<li>树状数组</li>
<li>线段树</li>
<li>LCT</li>
<li>按秩压缩并查集</li>
<li>路径压缩并查集</li>
<li>Dijsktra 单源最短路</li>
<li>Kruskal 最小生成树</li>
<li>Tarjan 缩点</li>
<li>点分治</li>
<li>树链剖分</li>
<li>平衡树</li>
<li>可持久化数组</li>
<li>可持久化线段树</li>
<li>线性基</li>
<li>矩阵</li>
<li>字符串哈希</li>
<li>Manacher</li>
<li>KMP</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">typedef</span> <span style="font-weight:bold;text-decoration:underline">int</span> readtype;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic">/* Header {{{ */</span>
</span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold">#include</span> <span style="color:#888;font-weight:bold">&lt;bits/stdc++.h&gt;</span><span style="color:#888;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold"></span><span style="font-weight:bold;text-decoration:underline">using</span> <span style="font-weight:bold;text-decoration:underline">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">template</span>&lt;<span style="font-weight:bold;text-decoration:underline">typename</span> type&gt; type beMin(type &amp;a, type b) { <span style="font-weight:bold;text-decoration:underline">return</span> a = (a &lt; b ? a : b); }
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">template</span>&lt;<span style="font-weight:bold;text-decoration:underline">typename</span> type&gt; type beMax(type &amp;a, type b) { <span style="font-weight:bold;text-decoration:underline">return</span> a = (a &gt; b ? a : b); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">typedef</span> <span style="font-weight:bold;text-decoration:underline">long</span> <span style="font-weight:bold;text-decoration:underline">long</span> var;
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">typedef</span> <span style="font-weight:bold;text-decoration:underline">long</span> <span style="font-weight:bold;text-decoration:underline">double</span> let;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>readtype <span style="color:#666;font-weight:bold;font-style:italic">read</span>() {
</span></span><span style="display:flex;"><span>  readtype a = 0, c = getchar(), s = 0;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">while</span> (!isdigit(c)) s |= c == <span style="color:#666;font-style:italic">&#39;-&#39;</span>, c = getchar();
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">while</span> (isdigit(c)) a = a * 10 + c - 48, c = getchar();
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">return</span> s ? -a : a;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold">#ifdef LOCAL_LOGGER
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold">#define logger(...) fprintf(stderr, __VA_ARGS__)
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold">#define abortif(v, ...) if (v) {logger(&#34;Error in Line %d, Function &#39;%s()&#39;.\nInfo: &#34;, __LINE__, __FUNCTION__); logger(__VA_ARGS__); exit(0);}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold">#else
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold">#define logger(...);
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold">#define abortif(v, ...);
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold"></span><span style="color:#888;font-style:italic">/* }}} */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">const</span> <span style="font-weight:bold;text-decoration:underline">int</span> N = 11000007;
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">const</span> <span style="font-weight:bold;text-decoration:underline">int</span> M = 110005;
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">const</span> <span style="font-weight:bold;text-decoration:underline">int</span> SIZE = 100;
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">const</span> <span style="font-weight:bold;text-decoration:underline">int</span> MOD = 1e9 + 7;
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">const</span> <span style="font-weight:bold;text-decoration:underline">int</span> INF = 0x3f3f3f3f;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">Line</span> {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> id, u, v, w;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">bool</span> <span style="font-weight:bold;text-decoration:underline">operator</span>&lt;(<span style="font-weight:bold;text-decoration:underline">const</span> Line t) <span style="font-weight:bold;text-decoration:underline">const</span> { <span style="font-weight:bold;text-decoration:underline">return</span> w &gt; t.w; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">namespace</span> BasisDataStructure {
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  <span style="font-weight:bold;text-decoration:underline">template</span> &lt;<span style="font-weight:bold;text-decoration:underline">class</span> <span style="color:#666;font-weight:bold;font-style:italic">tp</span>&gt; <span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">STable</span> { <span style="color:#888;font-style:italic">// P3865
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    tp val[N][21];
</span></span><span style="display:flex;"><span>    tp (*camp)(tp, tp);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">build</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, <span style="font-weight:bold;text-decoration:underline">int</span> *v) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) val[i][0] = v[i];
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= 20; ++i) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; ++j)
</span></span><span style="display:flex;"><span>          val[j][i] = camp(val[j][i - 1], val[j + (1 &lt;&lt; (i - 1))][i - 1]);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    tp <span style="color:#666;font-weight:bold;font-style:italic">query</span>(<span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> x = log(r - l + 1) / log(2);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> camp(val[l][x], val[r - (1 &lt;&lt; x) + 1][x]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">template</span> &lt;<span style="font-weight:bold;text-decoration:underline">class</span> <span style="color:#666;font-weight:bold;font-style:italic">tp</span>&gt; <span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">TreeArray</span> { <span style="color:#888;font-style:italic">// P3374 P3368
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    tp tree[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">modify</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, <span style="font-weight:bold;text-decoration:underline">int</span> t, <span style="font-weight:bold;text-decoration:underline">int</span> v) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = t; i &lt;= n; i += i &amp; -i) 
</span></span><span style="display:flex;"><span>        tree[i] += v;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    tp <span style="color:#666;font-weight:bold;font-style:italic">query</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      tp res = 0;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = t; i; i -= i &amp; -i)
</span></span><span style="display:flex;"><span>        res += tree[i];
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">/// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">SegmentTree</span> { <span style="color:#888;font-style:italic">// P3372 P3373
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="font-weight:bold;text-decoration:underline">public</span>:
</span></span><span style="display:flex;"><span>    var MOD;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">build</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, <span style="font-weight:bold;text-decoration:underline">int</span> *v) { build(v, 1, n, 1); }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">modifyAdd</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, <span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r, <span style="font-weight:bold;text-decoration:underline">int</span> v) { modify(l, r, v, 1, 1, n, 1); }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">modifyMul</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, <span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r, <span style="font-weight:bold;text-decoration:underline">int</span> v) { modify(l, r, 0, v, 1, n, 1); }
</span></span><span style="display:flex;"><span>    var <span style="color:#666;font-weight:bold;font-style:italic">query</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, <span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r) { <span style="font-weight:bold;text-decoration:underline">return</span> query(l, r, 1, n, 1); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">private</span>:
</span></span><span style="display:flex;"><span>    var tree[N &lt;&lt; 2], addtag[N &lt;&lt; 2], multag[N &lt;&lt; 2];
</span></span><span style="display:flex;"><span>    var <span style="color:#666;font-weight:bold;font-style:italic">mod</span>(var t) { <span style="font-weight:bold;text-decoration:underline">return</span> MOD ? t % MOD : t; }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">build</span>(<span style="font-weight:bold;text-decoration:underline">int</span> *v, <span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r, <span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> mid = (l + r) &gt;&gt; 1;
</span></span><span style="display:flex;"><span>      multag[t] = 1;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (l == r) {
</span></span><span style="display:flex;"><span>        tree[t] = v[mid];
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">return</span> ;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      build(v, l, mid, t &lt;&lt; 1), build(v, mid + 1, r, t &lt;&lt; 1 | 1);
</span></span><span style="display:flex;"><span>      tree[t] = mod(tree[t &lt;&lt; 1] + tree[t &lt;&lt; 1 | 1]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">optAdd</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t, <span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r, var v) {
</span></span><span style="display:flex;"><span>      addtag[t] = mod(addtag[t] + v), tree[t] = mod(tree[t] + mod((r - l + 1) * v));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">optMul</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t, var v) {
</span></span><span style="display:flex;"><span>      addtag[t] = mod(addtag[t] * v);
</span></span><span style="display:flex;"><span>      multag[t] = mod(multag[t] * v);
</span></span><span style="display:flex;"><span>      tree[t] = mod(tree[t] * v);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">pushdown</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t, <span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (multag[t] - 1) {
</span></span><span style="display:flex;"><span>        optMul(t &lt;&lt; 1, multag[t]), optMul(t &lt;&lt; 1 | 1, multag[t]);
</span></span><span style="display:flex;"><span>        multag[t] = 1;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (addtag[t]) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">int</span> mid = (l + r) &gt;&gt; 1;
</span></span><span style="display:flex;"><span>        optAdd(t &lt;&lt; 1, l, mid, addtag[t]), optAdd(t &lt;&lt; 1 | 1, mid + 1, r, addtag[t]);
</span></span><span style="display:flex;"><span>        addtag[t] = 0;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">modify</span>(<span style="font-weight:bold;text-decoration:underline">int</span> x, <span style="font-weight:bold;text-decoration:underline">int</span> y, <span style="font-weight:bold;text-decoration:underline">int</span> addVal, <span style="font-weight:bold;text-decoration:underline">int</span> mulVal, <span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r, <span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (x &gt; r || y &lt; l) <span style="font-weight:bold;text-decoration:underline">return</span> ;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> mid = (l + r) &gt;&gt; 1;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {
</span></span><span style="display:flex;"><span>        optMul(t, mulVal), optAdd(t, l, r, addVal);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">return</span> ;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      pushdown(t, l, r);
</span></span><span style="display:flex;"><span>      modify(x, y, addVal, mulVal, l, mid, t &lt;&lt; 1);
</span></span><span style="display:flex;"><span>      modify(x, y, addVal, mulVal, mid + 1, r, t &lt;&lt; 1 | 1);
</span></span><span style="display:flex;"><span>      tree[t] = mod(tree[t &lt;&lt; 1] + tree[t &lt;&lt; 1 | 1]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    var <span style="color:#666;font-weight:bold;font-style:italic">query</span>(<span style="font-weight:bold;text-decoration:underline">int</span> x, <span style="font-weight:bold;text-decoration:underline">int</span> y, <span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r, <span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (x &gt; r || y &lt; l) <span style="font-weight:bold;text-decoration:underline">return</span> 0;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> mid = (l + r) &gt;&gt; 1;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span style="font-weight:bold;text-decoration:underline">return</span> tree[t];
</span></span><span style="display:flex;"><span>      pushdown(t, l, r);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> mod(query(x, y, l, mid, t &lt;&lt; 1) + query(x, y, mid + 1, r, t &lt;&lt; 1 | 1));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">LinkCutTree</span> { <span style="color:#888;font-style:italic">// P3690
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="font-weight:bold;text-decoration:underline">int</span> tree[N], val[N], son[N][2], fa[N], size[N], revtag[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> cnt, sta[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">bool</span> <span style="color:#666;font-weight:bold;font-style:italic">nroot</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) { <span style="font-weight:bold;text-decoration:underline">return</span> t == son[fa[t]][0] || t == son[fa[t]][1]; }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">bool</span> <span style="color:#666;font-weight:bold;font-style:italic">isson</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) { <span style="font-weight:bold;text-decoration:underline">return</span> t == son[fa[t]][1]; }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">optRev</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      revtag[t] ^= 1;
</span></span><span style="display:flex;"><span>      swap(son[t][0], son[t][1]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">pushdown</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (revtag[t]) {
</span></span><span style="display:flex;"><span>        optRev(son[t][0]), optRev(son[t][1]);
</span></span><span style="display:flex;"><span>        revtag[t] = 0;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">update</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      tree[t] = tree[son[t][0]] ^ tree[son[t][1]] ^ val[t];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">rotate</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> f = fa[t], g = fa[f], tis = isson(t), fis = isson(f);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (nroot(f)) son[g][fis] = t;
</span></span><span style="display:flex;"><span>      fa[t] = g;
</span></span><span style="display:flex;"><span>      fa[son[t][tis ^ 1]] = f, son[f][tis] = son[t][tis ^ 1];
</span></span><span style="display:flex;"><span>      fa[f] = t, son[t][tis ^ 1] = f;
</span></span><span style="display:flex;"><span>      update(f), update(t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">splay</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> x = t;
</span></span><span style="display:flex;"><span>      sta[cnt = 1] = x;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">while</span> (nroot(x)) 
</span></span><span style="display:flex;"><span>        x = fa[x], sta[++cnt] = x;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">while</span> (cnt) pushdown(sta[cnt--]);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">while</span> (nroot(t)) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">int</span> f = fa[t];
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (!nroot(f)) rotate(t);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">else</span> <span style="font-weight:bold;text-decoration:underline">if</span> (isson(t) == isson(f)) rotate(f), rotate(t);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">else</span> rotate(t), rotate(t);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      update(t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">access</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 0; t; i = t, t = fa[t])
</span></span><span style="display:flex;"><span>        splay(t), son[t][1] = i, update(t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">makeroot</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      access(t), splay(t), optRev(t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">findroot</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      access(t), splay(t);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">while</span> (son[t][0]) 
</span></span><span style="display:flex;"><span>        pushdown(t), t = son[t][0];
</span></span><span style="display:flex;"><span>      splay(t);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> t;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">split</span>(<span style="font-weight:bold;text-decoration:underline">int</span> x, <span style="font-weight:bold;text-decoration:underline">int</span> y) {
</span></span><span style="display:flex;"><span>      makeroot(y), access(x), splay(x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">link</span>(<span style="font-weight:bold;text-decoration:underline">int</span> x, <span style="font-weight:bold;text-decoration:underline">int</span> y) {
</span></span><span style="display:flex;"><span>      makeroot(x);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (findroot(y) != x) 
</span></span><span style="display:flex;"><span>        fa[x] = y;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">cut</span>(<span style="font-weight:bold;text-decoration:underline">int</span> x, <span style="font-weight:bold;text-decoration:underline">int</span> y) {
</span></span><span style="display:flex;"><span>      split(x, y);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (son[x][0] == y &amp;&amp; !son[y][1]) 
</span></span><span style="display:flex;"><span>        son[x][0] = 0, fa[y] = 0;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  };
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">namespace</span> DisjointSetUnion { 
</span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span><span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">Union</span> { <span style="color:#888;font-style:italic">// P3367
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  <span style="font-weight:bold;text-decoration:underline">int</span> fa[N], dist[N];
</span></span><span style="display:flex;"><span>  Union() {
</span></span><span style="display:flex;"><span>    memset(fa, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(fa));
</span></span><span style="display:flex;"><span>    memset(dist, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(dist));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">init</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) fa[i] = i, dist[i] = 1;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">merge</span>(<span style="font-weight:bold;text-decoration:underline">int</span> u, <span style="font-weight:bold;text-decoration:underline">int</span> v) {
</span></span><span style="display:flex;"><span>    u = find(u), v = find(v);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (u == v) <span style="font-weight:bold;text-decoration:underline">return</span> ;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (dist[u] &gt; dist[v]) swap(u, v);
</span></span><span style="display:flex;"><span>    dist[v] = max(dist[v], dist[u] + 1);
</span></span><span style="display:flex;"><span>    fa[u] = v;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">find</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (fa[t] != t) <span style="font-weight:bold;text-decoration:underline">return</span> find(fa[t]);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> t;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>};
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">MergePathUnion</span> { <span style="color:#888;font-style:italic">// P3367
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  <span style="font-weight:bold;text-decoration:underline">int</span> fa[N];
</span></span><span style="display:flex;"><span>  MergePathUnion() {
</span></span><span style="display:flex;"><span>    memset(fa, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(fa));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">init</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) fa[i] = i;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">merge</span>(<span style="font-weight:bold;text-decoration:underline">int</span> u, <span style="font-weight:bold;text-decoration:underline">int</span> v) {
</span></span><span style="display:flex;"><span>    u = find(u), v = find(v);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (u == v) <span style="font-weight:bold;text-decoration:underline">return</span> ;
</span></span><span style="display:flex;"><span>    fa[u] = v;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">bool</span> <span style="color:#666;font-weight:bold;font-style:italic">check</span>(<span style="font-weight:bold;text-decoration:underline">int</span> u, <span style="font-weight:bold;text-decoration:underline">int</span> v) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> find(u) == find(v); 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">find</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (fa[t] != t) fa[t] = find(fa[t]);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> fa[t];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>};
</span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">namespace</span> Graph {
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  <span style="font-weight:bold;text-decoration:underline">int</span> top, fi[N], ne[M], to[M], co[M], inNum[N], outNum[N];
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">add</span>(<span style="font-weight:bold;text-decoration:underline">int</span> u, <span style="font-weight:bold;text-decoration:underline">int</span> v, <span style="font-weight:bold;text-decoration:underline">int</span> w = 0) {
</span></span><span style="display:flex;"><span>    ne[++top] = fi[u], fi[u] = top, to[top] = v, co[top] = w, outNum[u]++, inNum[v]++;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">clean</span>() {
</span></span><span style="display:flex;"><span>    top = 0;
</span></span><span style="display:flex;"><span>    memset(fi, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(fi));
</span></span><span style="display:flex;"><span>    memset(inNum, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(inNum));
</span></span><span style="display:flex;"><span>    memset(outNum, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(outNum));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">namespace</span> Dijsktra { <span style="color:#888;font-style:italic">// P4779
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">Node</span> {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> to, val;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">bool</span> <span style="font-weight:bold;text-decoration:underline">operator</span>&lt;(<span style="font-weight:bold;text-decoration:underline">const</span> Node t) <span style="font-weight:bold;text-decoration:underline">const</span> { <span style="font-weight:bold;text-decoration:underline">return</span> val &gt; t.val; };
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">bool</span> in[N];
</span></span><span style="display:flex;"><span>    priority_queue&lt;Node&gt; q;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">template</span> &lt;<span style="font-weight:bold;text-decoration:underline">class</span> <span style="color:#666;font-weight:bold;font-style:italic">tp</span>&gt; <span style="font-weight:bold;text-decoration:underline">void</span> getDist(tp *dist, <span style="font-weight:bold;text-decoration:underline">int</span> s) {
</span></span><span style="display:flex;"><span>      q.push((Node) {s, 0});
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">while</span> (!q.empty()) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">int</span> f = q.top().to;
</span></span><span style="display:flex;"><span>        q.pop();
</span></span><span style="display:flex;"><span>        in[f] = <span style="font-weight:bold;font-style:italic">false</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = fi[f]; i; i = ne[i]) {
</span></span><span style="display:flex;"><span>          <span style="font-weight:bold;text-decoration:underline">if</span> (dist[to[i]] &lt;= dist[f] + co[i]) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>          dist[to[i]] = dist[f] + co[i];
</span></span><span style="display:flex;"><span>          <span style="font-weight:bold;text-decoration:underline">if</span> (in[to[i]]) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>          in[to[i]] = <span style="font-weight:bold;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>          q.push((Node) {to[i], dist[to[i]]});
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  };
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">namespace</span> MinimumSpanningTree {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">namespace</span> Kruskal { <span style="color:#888;font-style:italic">// P3366
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>      <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>      DisjointSetUnion::MergePathUnion s;
</span></span><span style="display:flex;"><span>      vector&lt;Line&gt; getMST(<span style="font-weight:bold;text-decoration:underline">int</span> n, vector&lt;Line&gt; line) {
</span></span><span style="display:flex;"><span>        vector&lt;Line&gt; res;
</span></span><span style="display:flex;"><span>        s.init(n);
</span></span><span style="display:flex;"><span>        sort(line.begin(), line.end());
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = line.size() - 1; i &gt;= 0; --i) {
</span></span><span style="display:flex;"><span>          Line t = line.at(i);
</span></span><span style="display:flex;"><span>          <span style="font-weight:bold;text-decoration:underline">if</span> (s.check(t.u, t.v)) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>          s.merge(t.u, t.v);
</span></span><span style="display:flex;"><span>          res.push_back(t);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">return</span> res;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">namespace</span> Tarjan {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> T, dfn[N], low[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> cnt, sta[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">bool</span> insta[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> tot, root[N], col[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">Shrinkage</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) { <span style="color:#888;font-style:italic">// P3387
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>      <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>      dfn[t] = low[t] = ++T;
</span></span><span style="display:flex;"><span>      sta[++cnt] = t;
</span></span><span style="display:flex;"><span>      insta[t] = <span style="font-weight:bold;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = fi[t]; i; i = ne[i]) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (!dfn[to[i]]) Shrinkage(to[i]), low[t] = min(low[t], low[to[i]]);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">else</span> <span style="font-weight:bold;text-decoration:underline">if</span> (insta[to[i]]) low[t] = min(low[t], low[to[i]]);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (dfn[t] == low[t]) {
</span></span><span style="display:flex;"><span>        root[++tot] = t;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">while</span> (sta[cnt + 1] != t) {
</span></span><span style="display:flex;"><span>          <span style="font-weight:bold;text-decoration:underline">int</span> x = sta[cnt--];
</span></span><span style="display:flex;"><span>          insta[x] = <span style="font-weight:bold;font-style:italic">false</span>;
</span></span><span style="display:flex;"><span>          col[x] = tot;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">namespace</span> DivideAndConquer {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">namespace</span> Node {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">using</span> <span style="font-weight:bold;text-decoration:underline">namespace</span> Graph;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> root, minsize;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">bool</span> mark[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> size[N], dist[4];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">getSize</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t, <span style="font-weight:bold;text-decoration:underline">int</span> fa = 0) {
</span></span><span style="display:flex;"><span>      size[t] = 1;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = fi[t]; i; i = ne[i]) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (to[i] == fa || mark[to[i]]) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>        getSize(to[i], t);
</span></span><span style="display:flex;"><span>        size[t] += size[to[i]];
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">getRoot</span>(<span style="font-weight:bold;text-decoration:underline">int</span> rt, <span style="font-weight:bold;text-decoration:underline">int</span> t, <span style="font-weight:bold;text-decoration:underline">int</span> fa = 0) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> tsize = size[rt] - size[t];
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = fi[t]; i; i = ne[i]) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (to[i] == fa || mark[to[i]]) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>        getRoot(rt, to[i], t);
</span></span><span style="display:flex;"><span>        tsize = max(tsize, size[to[i]]);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (tsize &lt; minsize) minsize = tsize, root = t;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">getDist</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t, <span style="font-weight:bold;text-decoration:underline">int</span> s = 0, <span style="font-weight:bold;text-decoration:underline">int</span> fa = 0) {
</span></span><span style="display:flex;"><span>      dist[s % 3]++;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = fi[t]; i; i = ne[i]) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (to[i] == fa || mark[to[i]]) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>        getDist(to[i], s + co[i], t);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">getAns</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t, <span style="font-weight:bold;text-decoration:underline">int</span> s = 0) {
</span></span><span style="display:flex;"><span>      dist[0] = dist[1] = dist[2] = 0;
</span></span><span style="display:flex;"><span>      getDist(t, s);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> 2 * dist[1] * dist[2] + dist[0] * (dist[0] - 1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">DFS</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      getSize(t);
</span></span><span style="display:flex;"><span>      minsize = INF;
</span></span><span style="display:flex;"><span>      getRoot(t, t);
</span></span><span style="display:flex;"><span>      mark[root] = <span style="font-weight:bold;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> res = getAns(root);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = fi[root]; i; i = ne[i]) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (mark[to[i]]) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>        res -= getAns(to[i], co[i]);
</span></span><span style="display:flex;"><span>        res += DFS(to[i]);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">namespace</span> TreeChainPartition {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">namespace</span> Heavy {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">using</span> <span style="font-weight:bold;text-decoration:underline">namespace</span> Graph;
</span></span><span style="display:flex;"><span>    BasisDataStructure::SegmentTree tree;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> size[N], fa[N], deep[N], maxson[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> T, dfn[N], val[N], linetop[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">getInfo</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      deep[t] = deep[fa[t]] + 1;
</span></span><span style="display:flex;"><span>      size[t] = 1;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = fi[t]; i; i = ne[i]) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (to[i] == fa[t]) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>        fa[to[i]] = t;
</span></span><span style="display:flex;"><span>        getInfo(to[i]);
</span></span><span style="display:flex;"><span>        size[t] += size[to[i]];
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (size[to[i]] &gt; size[maxson[t]]) maxson[t] = to[i];
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">getLink</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      dfn[t] = ++T;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (t == maxson[fa[t]]) linetop[t] = linetop[fa[t]];
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">else</span> linetop[t] = t;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (maxson[t]) getLink(maxson[t]);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = fi[t]; i; i = ne[i]) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (to[i] == maxson[t] || to[i] == fa[t]) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>        getLink(to[i]);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">init</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, <span style="font-weight:bold;text-decoration:underline">int</span> *v) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (!dfn[i]) {
</span></span><span style="display:flex;"><span>          getInfo(i);
</span></span><span style="display:flex;"><span>          getLink(i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) val[dfn[i]] = v[i];
</span></span><span style="display:flex;"><span>      tree.build(n, val);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">lca</span>(<span style="font-weight:bold;text-decoration:underline">int</span> x, <span style="font-weight:bold;text-decoration:underline">int</span> y) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">while</span> (linetop[x] != linetop[y]) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (deep[linetop[x]] &lt; deep[linetop[y]]) swap(x, y);
</span></span><span style="display:flex;"><span>        x = fa[linetop[x]];
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (deep[x] &gt; deep[y]) swap(x, y);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> x;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">querySum</span>(<span style="font-weight:bold;text-decoration:underline">int</span> x, <span style="font-weight:bold;text-decoration:underline">int</span> y) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> res = 0;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">while</span> (linetop[x] != linetop[y]) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (deep[linetop[x]] &lt; deep[linetop[y]]) swap(x, y);
</span></span><span style="display:flex;"><span>        res += tree.query(T, dfn[linetop[x]], dfn[x]);
</span></span><span style="display:flex;"><span>        x = fa[linetop[x]];
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (deep[x] &gt; deep[y]) swap(x, y);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> res + tree.query(T, dfn[x], dfn[y]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">namespace</span> BalancedTree {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">Splay</span> { <span style="color:#888;font-style:italic">// P3369
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="font-weight:bold;text-decoration:underline">int</span> cnt, root, val[N], num[N], son[N][2], fa[N], size[N], revtag[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">bool</span> <span style="color:#666;font-weight:bold;font-style:italic">nroot</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) { <span style="font-weight:bold;text-decoration:underline">return</span> fa[t]; }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">bool</span> <span style="color:#666;font-weight:bold;font-style:italic">isson</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) { <span style="font-weight:bold;text-decoration:underline">return</span> t == son[fa[t]][1]; }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">optRev</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      revtag[t] ^= 1, swap(son[t][0], son[t][1]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">reverse</span>(<span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r) {
</span></span><span style="display:flex;"><span>      splay(kth(l - 1)), splay(kth(r + 1), root);
</span></span><span style="display:flex;"><span>      optRev(son[son[root][1]][0]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">echo</span>() { echo(root); }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">echo</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      pushdown(t);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (son[t][0]) echo(son[t][0]);
</span></span><span style="display:flex;"><span>      printf(<span style="color:#666;font-style:italic">&#34;%d &#34;</span>, t);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (son[t][1]) echo(son[t][1]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">update</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      size[t] = size[son[t][0]] + size[son[t][1]] + num[t];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">pushdown</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (revtag[t]) {
</span></span><span style="display:flex;"><span>        optRev(son[t][0]), optRev(son[t][1]);
</span></span><span style="display:flex;"><span>        revtag[t] = 0;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">rotate</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> f = fa[t], g = fa[f], tis = isson(t), fis = isson(f);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (nroot(f)) son[g][fis] = t;
</span></span><span style="display:flex;"><span>      fa[t] = g;
</span></span><span style="display:flex;"><span>      fa[son[t][tis ^ 1]] = f, son[f][tis] = son[t][tis ^ 1];
</span></span><span style="display:flex;"><span>      fa[f] = t, son[t][tis ^ 1] = f;
</span></span><span style="display:flex;"><span>      update(f), update(t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">splay</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t, <span style="font-weight:bold;text-decoration:underline">int</span> to = 0) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">while</span> (fa[t] != to) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (fa[fa[t]] == to) rotate(t);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">else</span> <span style="font-weight:bold;text-decoration:underline">if</span> (isson(t) == isson(fa[t])) rotate(fa[t]), rotate(t);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">else</span> rotate(t), rotate(t);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (!to) root = t;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">build</span>(<span style="font-weight:bold;text-decoration:underline">int</span> l,<span style="font-weight:bold;text-decoration:underline">int</span> r, <span style="font-weight:bold;text-decoration:underline">int</span> f) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (l &gt; r) <span style="font-weight:bold;text-decoration:underline">return</span> 0;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> mid = (l + r) &gt;&gt; 1, t = ++cnt;
</span></span><span style="display:flex;"><span>      val[t] = mid, fa[t] = f, size[t] = num[t] = 1;
</span></span><span style="display:flex;"><span>      son[t][0] = build(l, mid - 1, t), son[t][1] = build(mid + 1, r, t);
</span></span><span style="display:flex;"><span>      update(t);
</span></span><span style="display:flex;"><span>      root = t;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> t;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">insert</span>(<span style="font-weight:bold;text-decoration:underline">int</span> v) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (find(v)) {
</span></span><span style="display:flex;"><span>        size[root]++, num[root]++;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">return</span> ;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> t = root;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = t; size[i]; i = son[i][v &gt; val[i]]) t = i;
</span></span><span style="display:flex;"><span>      val[++cnt] = v, size[cnt] = num[cnt] = 1, fa[cnt] = t;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (t) son[t][v &gt; val[t]] = cnt;
</span></span><span style="display:flex;"><span>      splay(cnt);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">bool</span> <span style="color:#666;font-weight:bold;font-style:italic">find</span>(<span style="font-weight:bold;text-decoration:underline">int</span> v) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = root; size[i]; i = son[i][v &gt; val[i]]) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (val[i] == v) {
</span></span><span style="display:flex;"><span>          splay(i);
</span></span><span style="display:flex;"><span>          <span style="font-weight:bold;text-decoration:underline">return</span> <span style="font-weight:bold;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> <span style="font-weight:bold;font-style:italic">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">next</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t, <span style="font-weight:bold;text-decoration:underline">int</span> x) {
</span></span><span style="display:flex;"><span>      t = son[t][x];
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">while</span> (t &amp;&amp; son[t][x ^ 1]) t = son[t][x ^ 1];
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> t;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">erase</span>(<span style="font-weight:bold;text-decoration:underline">int</span> v) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (!find(v)) <span style="font-weight:bold;text-decoration:underline">return</span> ;
</span></span><span style="display:flex;"><span>      size[root]--, num[root]--;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (num[root]) <span style="font-weight:bold;text-decoration:underline">return</span> ;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> l = next(root, 0), r = next(root, 1);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (!l) {
</span></span><span style="display:flex;"><span>        splay(r);
</span></span><span style="display:flex;"><span>        val[son[root][0]] = 0;
</span></span><span style="display:flex;"><span>        son[root][0] = 0;
</span></span><span style="display:flex;"><span>      } <span style="font-weight:bold;text-decoration:underline">else</span> <span style="font-weight:bold;text-decoration:underline">if</span> (!r) {
</span></span><span style="display:flex;"><span>        splay(l);
</span></span><span style="display:flex;"><span>        val[son[root][1]] = 0;
</span></span><span style="display:flex;"><span>        son[root][1] = 0;
</span></span><span style="display:flex;"><span>      } <span style="font-weight:bold;text-decoration:underline">else</span> {
</span></span><span style="display:flex;"><span>        splay(l), splay(r, l);
</span></span><span style="display:flex;"><span>        val[son[son[root][1]][0]] = 0;
</span></span><span style="display:flex;"><span>        son[son[root][1]][0] = 0;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">rank</span>(<span style="font-weight:bold;text-decoration:underline">int</span> v) {
</span></span><span style="display:flex;"><span>      insert(v);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> res = size[son[root][0]] + 1;
</span></span><span style="display:flex;"><span>      erase(v);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">kth</span>(<span style="font-weight:bold;text-decoration:underline">int</span> k) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> t = root;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">while</span> (k) {
</span></span><span style="display:flex;"><span>        pushdown(t);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">int</span> base = size[son[t][0]], cost = size[son[t][0]] + num[t];
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (base &lt; k &amp;&amp; cost &gt;= k) {
</span></span><span style="display:flex;"><span>          splay(t);
</span></span><span style="display:flex;"><span>          <span style="font-weight:bold;text-decoration:underline">return</span> val[t];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (base &gt;= k) t = son[t][0];
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">else</span> k -= cost, t = son[t][1];
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> -1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">fore</span>(<span style="font-weight:bold;text-decoration:underline">int</span> v) {
</span></span><span style="display:flex;"><span>      insert(v);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> res = val[next(root, 0)];
</span></span><span style="display:flex;"><span>      erase(v);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">succ</span>(<span style="font-weight:bold;text-decoration:underline">int</span> v) {
</span></span><span style="display:flex;"><span>      insert(v);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> res = val[next(root, 1)];
</span></span><span style="display:flex;"><span>      erase(v);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  };
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">namespace</span> Persistence {
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  <span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">Array</span> { <span style="color:#888;font-style:italic">// P3919
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="font-weight:bold;text-decoration:underline">public</span>:
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> cnt, root[N];
</span></span><span style="display:flex;"><span>    Array() {
</span></span><span style="display:flex;"><span>      T = 0;
</span></span><span style="display:flex;"><span>      memset(root, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(root));
</span></span><span style="display:flex;"><span>      memset(tree, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(tree));
</span></span><span style="display:flex;"><span>      memset(lson, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(lson));
</span></span><span style="display:flex;"><span>      memset(rson, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(rson));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">build</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, <span style="font-weight:bold;text-decoration:underline">int</span> *v) {
</span></span><span style="display:flex;"><span>      build(v, 1, n, root[0]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">modify</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, <span style="font-weight:bold;text-decoration:underline">int</span> p, <span style="font-weight:bold;text-decoration:underline">int</span> v, <span style="font-weight:bold;text-decoration:underline">int</span> t) { <span style="font-weight:bold;text-decoration:underline">return</span> modify(p, v, 1, n, root[t]); }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">query</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, <span style="font-weight:bold;text-decoration:underline">int</span> p, <span style="font-weight:bold;text-decoration:underline">int</span> t) { <span style="font-weight:bold;text-decoration:underline">return</span> query(p, 1, n, root[t]); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">private</span>:
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> T, tree[N &lt;&lt; 4], lson[N &lt;&lt; 4], rson[N &lt;&lt; 4];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">build</span>(<span style="font-weight:bold;text-decoration:underline">int</span> *v, <span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r, <span style="font-weight:bold;text-decoration:underline">int</span> &amp;t) {
</span></span><span style="display:flex;"><span>      t = ++T;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> mid = (l + r) &gt;&gt; 1;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (l == r) {
</span></span><span style="display:flex;"><span>        tree[t] = v[mid];
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">return</span> ;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      build(v, l, mid, lson[t]), build(v, mid + 1, r, rson[t]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">modify</span>(<span style="font-weight:bold;text-decoration:underline">int</span> p, <span style="font-weight:bold;text-decoration:underline">int</span> v, <span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r, <span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> rt = ++T, mid = (l + r) &gt;&gt; 1;
</span></span><span style="display:flex;"><span>      tree[rt] = tree[t], lson[rt] = lson[t], rson[rt] = rson[t];
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (l == r) tree[rt] = v;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">else</span> <span style="font-weight:bold;text-decoration:underline">if</span> (p &lt;= mid) lson[rt] = modify(p, v, l, mid, lson[t]);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">else</span> rson[rt] = modify(p, v, mid + 1, r, rson[t]);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> rt;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">query</span>(<span style="font-weight:bold;text-decoration:underline">int</span> p, <span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r, <span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> mid = (l + r) &gt;&gt; 1;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (l == r) <span style="font-weight:bold;text-decoration:underline">return</span> tree[t];
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (p &lt;= mid) <span style="font-weight:bold;text-decoration:underline">return</span> query(p, l, mid, lson[t]);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> query(p, mid + 1, r, rson[t]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  };
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">SegmentTree</span> { <span style="color:#888;font-style:italic">// P3834
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="font-weight:bold;text-decoration:underline">public</span>:
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> cnt, root[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> num, val[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">build</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, <span style="font-weight:bold;text-decoration:underline">int</span> *v) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) val[i] = v[i];
</span></span><span style="display:flex;"><span>      sort(val + 1, val + n + 1);
</span></span><span style="display:flex;"><span>      num = unique(val + 1, val + n + 1) - val - 1;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i)
</span></span><span style="display:flex;"><span>        root[i] = modify(
</span></span><span style="display:flex;"><span>            lower_bound(val + 1, val + num + 1, v[i]) - val, 
</span></span><span style="display:flex;"><span>            1, 1, num, root[i - 1]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">queryKth</span>(<span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r, <span style="font-weight:bold;text-decoration:underline">int</span> k) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> queryKth(k, 1, num, root[l - 1], root[r]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">private</span>:
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> T, tree[N &lt;&lt; 4], lson[N &lt;&lt; 4], rson[N &lt;&lt; 4];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">modify</span>(<span style="font-weight:bold;text-decoration:underline">int</span> p, <span style="font-weight:bold;text-decoration:underline">int</span> v, <span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r, <span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> rt = ++T, mid = (l + r) &gt;&gt; 1;
</span></span><span style="display:flex;"><span>      tree[rt] = tree[t] + 1, lson[rt] = lson[t], rson[rt] = rson[t];
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (l == r) <span style="font-weight:bold;text-decoration:underline">return</span> rt;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (p &lt;= mid) lson[rt] = modify(p, v, l, mid, lson[t]);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">else</span> rson[rt] = modify(p, v, mid + 1, r, rson[t]);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> rt;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">queryKth</span>(<span style="font-weight:bold;text-decoration:underline">int</span> k, <span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r, <span style="font-weight:bold;text-decoration:underline">int</span> lt, <span style="font-weight:bold;text-decoration:underline">int</span> rt) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> mid = (l + r) &gt;&gt; 1;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (l == r) <span style="font-weight:bold;text-decoration:underline">return</span> val[mid];
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (tree[lson[rt]] - tree[lson[lt]] &gt;= k) <span style="font-weight:bold;text-decoration:underline">return</span> queryKth(k, l, mid, lson[lt], lson[rt]);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> queryKth(k - (tree[lson[rt]] - tree[lson[lt]]), mid + 1, r, rson[lt], rson[rt]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  };
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">Union</span> {
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">namespace</span> Math {
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  <span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">Basis</span> { <span style="color:#888;font-style:italic">// P3812
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    var basis[64];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">insert</span>(var v) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 60; i &gt;= 0; --i) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (!((v &gt;&gt; i) &amp; 1)) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (!basis[i]) {
</span></span><span style="display:flex;"><span>          basis[i] = v;
</span></span><span style="display:flex;"><span>          <span style="font-weight:bold;text-decoration:underline">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        v ^= basis[i];
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">bool</span> <span style="color:#666;font-weight:bold;font-style:italic">testInsert</span>(var v) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 60; i &gt;= 0; --i) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (!((v &gt;&gt; i) &amp; 1)) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (!basis[i]) <span style="font-weight:bold;text-decoration:underline">return</span> <span style="font-weight:bold;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>        v ^= basis[i];
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> <span style="font-weight:bold;font-style:italic">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    var <span style="color:#666;font-weight:bold;font-style:italic">queryMax</span>(var v = 0) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 60; i &gt;= 0; --i) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> ((v ^ basis[i]) &gt; v) v ^= basis[i];
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> v;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">format</span>() {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 60; i &gt;= 0; --i) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> j = i - 1; j &gt;= 0; --j) {
</span></span><span style="display:flex;"><span>          <span style="font-weight:bold;text-decoration:underline">if</span> (!((basis[i] &gt;&gt; j) &amp; 1)) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>          basis[i] ^= basis[j];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  };
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">Matrix</span> { <span style="color:#888;font-style:italic">// P3390
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    var num[SIZE + 1][SIZE + 1];
</span></span><span style="display:flex;"><span>    Matrix() { memset(num, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(num)); }
</span></span><span style="display:flex;"><span>    Matrix(<span style="font-weight:bold;text-decoration:underline">int</span> t) { *<span style="font-weight:bold;text-decoration:underline">this</span> = t; }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="font-weight:bold;text-decoration:underline">operator</span>=(var t) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= SIZE; ++i) num[i][i] = t;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    Matrix <span style="font-weight:bold;text-decoration:underline">operator</span>*(Matrix t) {
</span></span><span style="display:flex;"><span>      Matrix res;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= SIZE; ++i) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> k = 1; k &lt;= SIZE; ++k) {
</span></span><span style="display:flex;"><span>          <span style="font-weight:bold;text-decoration:underline">if</span> (!num[i][k]) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>          <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> j = 1; j &lt;= SIZE; ++j) {
</span></span><span style="display:flex;"><span>            (res.num[i][j] += (num[i][k] * t.num[k][j]) % MOD) %= MOD;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="font-weight:bold;text-decoration:underline">operator</span>*=(Matrix t) { *<span style="font-weight:bold;text-decoration:underline">this</span> = *<span style="font-weight:bold;text-decoration:underline">this</span> * t; }
</span></span><span style="display:flex;"><span>    Matrix <span style="font-weight:bold;text-decoration:underline">operator</span>^(var y) {
</span></span><span style="display:flex;"><span>      Matrix res = 1, x = *<span style="font-weight:bold;text-decoration:underline">this</span>;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">while</span> (y) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (y &amp; 1) res *= x;
</span></span><span style="display:flex;"><span>        x *= x;
</span></span><span style="display:flex;"><span>        y &gt;&gt;= 1;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  };
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">template</span>&lt;<span style="font-weight:bold;text-decoration:underline">class</span> <span style="color:#666;font-weight:bold;font-style:italic">tp</span>&gt; <span style="font-weight:bold;text-decoration:underline">void</span> getInv(<span style="font-weight:bold;text-decoration:underline">int</span> n, var p, tp *inv) { <span style="color:#888;font-style:italic">// P3811
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    inv[0] = inv[1] = 1;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 2; i &lt;= n; ++i) inv[i] = ((p - p / i) * inv[p % i]) % p;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  var <span style="color:#666;font-weight:bold;font-style:italic">qpow</span>(var x, var y, var p) { <span style="color:#888;font-style:italic">// P1226
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    var res = 1;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">while</span> (y) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (y &amp; 1) (res *= x) %= p;
</span></span><span style="display:flex;"><span>      (x *= x) %= p;
</span></span><span style="display:flex;"><span>      y &gt;&gt;= 1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> res;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  var <span style="color:#666;font-weight:bold;font-style:italic">gcd</span>(var a, var b) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (!b) <span style="font-weight:bold;text-decoration:underline">return</span> a;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> gcd(b, a % b);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">namespace</span> String {
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  <span style="font-weight:bold;text-decoration:underline">namespace</span> Hash { <span style="color:#888;font-style:italic">// P3370
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="font-weight:bold;text-decoration:underline">const</span> <span style="font-weight:bold;text-decoration:underline">int</span> BASE1 = 107, BASE2 = 109;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">const</span> <span style="font-weight:bold;text-decoration:underline">int</span> MOD1 = 1e9 + 7, MOD2 = 1e9 + 9;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">Atom</span> {
</span></span><span style="display:flex;"><span>      var x, y;
</span></span><span style="display:flex;"><span>      Atom() { x = 0, y = 0; }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">insert</span>(var v) {
</span></span><span style="display:flex;"><span>        ((x *= BASE1) += v) %= MOD1, ((y *= BASE2) += v) %= MOD2;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      var <span style="color:#666;font-weight:bold;font-style:italic">val</span>() {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">return</span> (x * MOD2) + y;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">HashTable</span> {
</span></span><span style="display:flex;"><span>      var val[N + 1000], num[N + 1000];
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">insert</span>(Atom x) {
</span></span><span style="display:flex;"><span>        var v = x.val();
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">int</span> t = v % N;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">while</span> (val[t] &amp;&amp; val[t] != v) t++;
</span></span><span style="display:flex;"><span>        val[t] = v, num[t]++;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">return</span> num[t];
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  };
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">namespace</span> Manacher { <span style="color:#888;font-style:italic">// P3805
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="font-weight:bold;text-decoration:underline">char</span> S[N &lt;&lt; 1];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">getLen</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, <span style="font-weight:bold;text-decoration:underline">char</span> *s, <span style="font-weight:bold;text-decoration:underline">int</span> *len) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 0; i &lt; n; ++i) S[i * 2] = s[i], S[i * 2 + 1] = <span style="color:#666;font-style:italic">&#39;#&#39;</span>;
</span></span><span style="display:flex;"><span>      n = n * 2 + 2;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> pos = 0;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 0; i &lt; n; ++i) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (pos + len[pos] &gt; i) len[i] = min(pos + len[pos] - i, len[pos * 2 - i]);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">while</span> (S[i - len[i]] == S[i + len[i]]) len[i]++;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (i + len[i] &gt; pos + len[pos]) pos = i;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  };
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">namespace</span> KMP { <span style="color:#888;font-style:italic">// P3375
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="color:#888;font-style:italic">// {{{
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>    <span style="font-weight:bold;text-decoration:underline">int</span> fail[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">getFail</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, <span style="font-weight:bold;text-decoration:underline">char</span> *s) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 2, t = 0; i &lt;= n; ++i) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">while</span> (t &amp;&amp; s[t + 1] != s[i]) t = fail[t];
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (s[t + 1] == s[i]) fail[i] = ++t;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    vector&lt;<span style="font-weight:bold;text-decoration:underline">int</span>&gt; match(<span style="font-weight:bold;text-decoration:underline">int</span> n, <span style="font-weight:bold;text-decoration:underline">char</span> *S, <span style="font-weight:bold;text-decoration:underline">int</span> m, <span style="font-weight:bold;text-decoration:underline">char</span> *T) {
</span></span><span style="display:flex;"><span>      getFail(n, S);
</span></span><span style="display:flex;"><span>      vector&lt;<span style="font-weight:bold;text-decoration:underline">int</span>&gt; res;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1, t = 0; i &lt;= m; ++i) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (t &amp;&amp; S[t + 1] != T[i]) t = fail[t];
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (S[t + 1] == T[i]) t++;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (t == n) res.push_back(i - n + 1);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>  };
</span></span><span style="display:flex;"><span>  <span style="color:#888;font-style:italic">// }}}
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">using</span> <span style="font-weight:bold;text-decoration:underline">namespace</span> DivideAndConquer::Node;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">main</span>() {
</span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold">#ifndef ONLINE_JUDGE
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold"></span>  freopen(<span style="color:#666;font-style:italic">&#34;tmp.in&#34;</span>, <span style="color:#666;font-style:italic">&#34;r&#34;</span>, stdin);
</span></span><span style="display:flex;"><span>  freopen(<span style="color:#666;font-style:italic">&#34;tmp.out&#34;</span>, <span style="color:#666;font-style:italic">&#34;w&#34;</span>, stdout);
</span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold">#endif
</span></span></span><span style="display:flex;"><span><span style="color:#888;font-weight:bold"></span>  <span style="font-weight:bold;text-decoration:underline">int</span> n = read();
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 2; i &lt;= n; ++i) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> u = read(), v = read(), w = read();
</span></span><span style="display:flex;"><span>    add(u, v, w), add(v, u, w);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> x = DFS(1) + n, y = n * n, g = Math::gcd(x, y);
</span></span><span style="display:flex;"><span>  printf(<span style="color:#666;font-style:italic">&#34;%d/%d</span><span style="color:#666;font-style:italic">\n</span><span style="color:#666;font-style:italic">&#34;</span>, x / g, y / g);
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="kmp-字符串匹配">
  KMP 字符串匹配
  <a class="heading-link" href="#kmp-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8c%b9%e9%85%8d">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。<br>
现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。</p>
<p>定义一个字符串 $s$ 的 border 为 $s$ 的一个<strong>非 $s$ 本身</strong>的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。<br>
对于 $s_2$，你还需要求出对于其每个前缀 $s&rsquo;$ 的最长 border $t&rsquo;$ 的长度。</p>
<p>对于全部的测试点，保证 $1 \leq |s_1|,|s_2| \leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">const</span> <span style="font-weight:bold;text-decoration:underline">int</span> LEN = 1000000;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">char</span> s1[LEN + 1], s2[LEN + 1];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> fail[LEN + 1];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">solve</span>() {
</span></span><span style="display:flex;"><span>  ios::sync_with_stdio(<span style="font-weight:bold;font-style:italic">false</span>);
</span></span><span style="display:flex;"><span>  cin &gt;&gt; s1 &gt;&gt; s2;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> n = strlen(s1), m = strlen(s2), t = 0;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt; m; i++) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">while</span> (s2[i] != s2[t] &amp;&amp; t) t = fail[t];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (s2[i] == s2[t]) fail[i + 1] = ++t;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  t = 0;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 0; i &lt; n; i++) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">while</span> (s1[i] != s2[t] &amp;&amp; t) t = fail[t];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (s1[i] == s2[t]) t++;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (t == m) cout &lt;&lt; i - m + 2 &lt;&lt; endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= m; i++) cout &lt;&lt; fail[i] &lt;&lt; <span style="color:#666;font-style:italic">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>  cout &lt;&lt; endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="负环">
  负环
  <a class="heading-link" href="#%e8%b4%9f%e7%8e%af">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>给定一个 $n$ 个点的有向图，请求出图中是否存在<strong>从顶点 $1$ 出发能到达</strong>的负环。</p>
<p>负环的定义是：一条边权之和为负数的回路。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">const</span> <span style="font-weight:bold;text-decoration:underline">int</span> MAXN = 20000;
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">const</span> <span style="font-weight:bold;text-decoration:underline">int</span> MAXM = 30000;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> n, m;
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> top, fi[MAXN + 1];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> ne[2 * MAXM + 1], to[2 * MAXM + 1];
</span></span><span style="display:flex;"><span>ll co[2 * MAXM + 1];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> dist[MAXN + 1], deep[MAXN + 1];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">bool</span> arrive[MAXN + 1];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">solve</span>();
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">bool</span> <span style="color:#666;font-weight:bold;font-style:italic">find</span>(<span style="font-weight:bold;text-decoration:underline">int</span>);
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">add</span>(<span style="font-weight:bold;text-decoration:underline">int</span>, <span style="font-weight:bold;text-decoration:underline">int</span>, <span style="font-weight:bold;text-decoration:underline">int</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">solve</span>() {
</span></span><span style="display:flex;"><span>  top = 0;memset(fi, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(fi));
</span></span><span style="display:flex;"><span>  memset(ne, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(ne)); memset(to, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(to));
</span></span><span style="display:flex;"><span>  memset(co, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(co)); memset(arrive, <span style="font-weight:bold;font-style:italic">false</span>, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(arrive));
</span></span><span style="display:flex;"><span>  cin &gt;&gt; n &gt;&gt; m;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= m; i++) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> u, v, w;
</span></span><span style="display:flex;"><span>    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
</span></span><span style="display:flex;"><span>    add(u, v, w);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (w &gt;= 0) add(v, u, w);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">bool</span> have = <span style="font-weight:bold;font-style:italic">false</span>;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; i++) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (!arrive[i] &amp;&amp; find(i)) {
</span></span><span style="display:flex;"><span>      have = <span style="font-weight:bold;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">if</span> (have) cout &lt;&lt; <span style="color:#666;font-style:italic">&#34;YE5&#34;</span> &lt;&lt; endl;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">else</span> cout &lt;&lt; <span style="color:#666;font-style:italic">&#34;N0&#34;</span> &lt;&lt; endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">bool</span> <span style="color:#666;font-weight:bold;font-style:italic">find</span>(<span style="font-weight:bold;text-decoration:underline">int</span> begin) {
</span></span><span style="display:flex;"><span>  memset(dist, 16, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(dist));
</span></span><span style="display:flex;"><span>  dist[begin] = 0;
</span></span><span style="display:flex;"><span>  memset(deep, -1, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(deep));
</span></span><span style="display:flex;"><span>  deep[begin] = 0;
</span></span><span style="display:flex;"><span>  queue&lt;<span style="font-weight:bold;text-decoration:underline">int</span>&gt;q;
</span></span><span style="display:flex;"><span>  q.push(begin);
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">while</span> (!q.empty()) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> f = q.front(); q.pop();
</span></span><span style="display:flex;"><span>    arrive[f] = <span style="font-weight:bold;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = fi[f]; i; i = ne[i]) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (dist[f] + co[i] &lt; dist[to[i]]) {
</span></span><span style="display:flex;"><span>        dist[to[i]] = dist[f] + co[i];
</span></span><span style="display:flex;"><span>        deep[to[i]] = deep[f] + 1;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (deep[to[i]] &gt; n) <span style="font-weight:bold;text-decoration:underline">return</span> <span style="font-weight:bold;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>        q.push(to[i]);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">return</span> <span style="font-weight:bold;font-style:italic">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">add</span>(<span style="font-weight:bold;text-decoration:underline">int</span> u, <span style="font-weight:bold;text-decoration:underline">int</span> v, <span style="font-weight:bold;text-decoration:underline">int</span> w) {
</span></span><span style="display:flex;"><span>  top++; ne[top] = fi[u]; fi[u] = top;
</span></span><span style="display:flex;"><span>  to[top] = v; co[top] = w;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="最小费用最大流">
  最小费用最大流
  <a class="heading-link" href="#%e6%9c%80%e5%b0%8f%e8%b4%b9%e7%94%a8%e6%9c%80%e5%a4%a7%e6%b5%81">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">class</span> <span style="color:#666;font-weight:bold;font-style:italic">Graph</span> {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">public</span>:
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> top, fi[N], ne[M &lt;&lt; 1], to[M &lt;&lt; 1], fl[M &lt;&lt; 1], co[M &lt;&lt; 1];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> S, T;
</span></span><span style="display:flex;"><span>    var dist[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> head, tail, q[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">bool</span> inq[N];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> fromNode[N], fromLine[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Graph() {
</span></span><span style="display:flex;"><span>      top = 1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">Add</span>(<span style="font-weight:bold;text-decoration:underline">int</span> u, <span style="font-weight:bold;text-decoration:underline">int</span> v, <span style="font-weight:bold;text-decoration:underline">int</span> f, <span style="font-weight:bold;text-decoration:underline">int</span> w) {
</span></span><span style="display:flex;"><span>      ne[++top] = fi[u], fi[u] = top, to[top] = v, fl[top] = f, co[top] = w;
</span></span><span style="display:flex;"><span>      ne[++top] = fi[v], fi[v] = top, to[top] = u, fl[top] = 0, co[top] = -w;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">bool</span> <span style="color:#666;font-weight:bold;font-style:italic">SPFA</span>() {
</span></span><span style="display:flex;"><span>      memset(dist, 0x3f, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(dist));
</span></span><span style="display:flex;"><span>      dist[S] = 0;
</span></span><span style="display:flex;"><span>      q[head = tail = 1] = S;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">while</span> (head &lt;= tail) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">int</span> t = q[head++];
</span></span><span style="display:flex;"><span>        inq[t] = <span style="font-weight:bold;font-style:italic">false</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = fi[t]; i; i = ne[i]) {
</span></span><span style="display:flex;"><span>          <span style="font-weight:bold;text-decoration:underline">if</span> (!fl[i] || dist[to[i]] &lt;= dist[t] + co[i]) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>          dist[to[i]] = dist[t] + co[i];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          fromNode[to[i]] = t, fromLine[to[i]] = i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          <span style="font-weight:bold;text-decoration:underline">if</span> (inq[to[i]]) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>          q[++tail] = to[i];
</span></span><span style="display:flex;"><span>          inq[to[i]] = <span style="font-weight:bold;font-style:italic">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> dist[T] != 0x3f3f3f3f3f3f3f3f;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">MCMF</span>(var &amp;sum_flow, var &amp;cost) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">while</span> (SPFA()) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">int</span> flow = 0x3f3f3f3f;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = T; i != S; i = fromNode[i])
</span></span><span style="display:flex;"><span>          flow = min(flow, fl[fromLine[i]]);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = T; i != S; i = fromNode[i])
</span></span><span style="display:flex;"><span>          fl[fromLine[i]] -= flow, fl[fromLine[i] ^ 1] += flow;
</span></span><span style="display:flex;"><span>        sum_flow += flow;
</span></span><span style="display:flex;"><span>        cost += dist[T] * flow;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">class</span> <span style="color:#666;font-weight:bold;font-style:italic">Solve</span> : <span style="font-weight:bold;text-decoration:underline">public</span> Graph {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">public</span>:
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> n, m;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">main</span>() {
</span></span><span style="display:flex;"><span>      n = read(), m = read(), S = read(), T = read();
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= m; ++i) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">int</span> u = read(), v = read(), w = read(), f = read();
</span></span><span style="display:flex;"><span>        Add(u, v, w, f);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      var flow = 0, cost = 0;
</span></span><span style="display:flex;"><span>      MCMF(flow, cost);
</span></span><span style="display:flex;"><span>      printf(<span style="color:#666;font-style:italic">&#34;%lld %lld</span><span style="color:#666;font-style:italic">\n</span><span style="color:#666;font-style:italic">&#34;</span>, flow, cost);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> 0;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="网络流-dinic">
  网络流 Dinic
  <a class="heading-link" href="#%e7%bd%91%e7%bb%9c%e6%b5%81-dinic">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> n, m, S, T;
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> top = 1, fi[N], ne[M &lt;&lt; 2], to[M &lt;&lt; 2], fl[M &lt;&lt; 2];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> deep[N], cur[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">add</span>(<span style="font-weight:bold;text-decoration:underline">int</span> u, <span style="font-weight:bold;text-decoration:underline">int</span> v, <span style="font-weight:bold;text-decoration:underline">int</span> w) {
</span></span><span style="display:flex;"><span>    top++, ne[top] = fi[u], fi[u] = top, to[top] = v, fl[top] = w;
</span></span><span style="display:flex;"><span>    top++, ne[top] = fi[v], fi[v] = top, to[top] = u, fl[top] = 0;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">Dinic</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> res = 0;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">while</span> (BFS()) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) cur[i] = fi[i];
</span></span><span style="display:flex;"><span>        res += DFS(S, INF);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">bool</span> <span style="color:#666;font-weight:bold;font-style:italic">BFS</span>() {
</span></span><span style="display:flex;"><span>    memset(deep, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(deep));
</span></span><span style="display:flex;"><span>    deep[S] = 1;
</span></span><span style="display:flex;"><span>    queue&lt;<span style="font-weight:bold;text-decoration:underline">int</span>&gt; q;
</span></span><span style="display:flex;"><span>    q.push(S);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">while</span> (!q.empty()) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">int</span> f = q.front();
</span></span><span style="display:flex;"><span>        q.pop();
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = fi[f]; i; i = ne[i]) {
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold;text-decoration:underline">if</span> (!fl[i] || deep[to[i]]) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>            deep[to[i]] = deep[f] + 1;
</span></span><span style="display:flex;"><span>            q.push(to[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> deep[T];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">DFS</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t, <span style="font-weight:bold;text-decoration:underline">int</span> flow) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> sumFlow = 0;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (t == T) <span style="font-weight:bold;text-decoration:underline">return</span> flow;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">while</span> (cur[t]) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">int</span> i = cur[t];
</span></span><span style="display:flex;"><span>        cur[t] = ne[cur[t]];
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (!fl[i] || deep[to[i]] != deep[t] + 1) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">int</span> tFlow = DFS(to[i], min(flow - sumFlow, fl[i]));
</span></span><span style="display:flex;"><span>        fl[i] -= tFlow;
</span></span><span style="display:flex;"><span>        fl[i ^ 1] += tFlow;
</span></span><span style="display:flex;"><span>        sumFlow += tFlow;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> sumFlow;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="笛卡尔树">
  笛卡尔树
  <a class="heading-link" href="#%e7%ac%9b%e5%8d%a1%e5%b0%94%e6%a0%91">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>给定一个 $1 \sim n$ 的排列 $p$，构建其笛卡尔树。</p>
<p>即构建一棵二叉树，满足：</p>
<ol>
<li>每个节点的编号满足二叉搜索树的性质。</li>
<li>节点 $i$ 的权值为 $p_i$，每个节点的权值满足小根堆的性质。</li>
</ol>
<p>设 $l_i,r_i$ 分别表示节点 $i$ 的左右儿子的编号（若不存在则为 $0$）。</p>
<p>一行两个整数，分别表示 $\operatorname{xor}<em>{i = 1}^n i \times (l_i + 1)$ 和 $\operatorname{xor}</em>{i = 1}^n i \times (r_i + 1)$。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> n, p[N];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> son[N][2];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> cnt, sta[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">solve</span>() {
</span></span><span style="display:flex;"><span>	n = read();
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) p[i] = read();
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) {
</span></span><span style="display:flex;"><span>		<span style="font-weight:bold;text-decoration:underline">while</span> (cnt &amp;&amp; p[sta[cnt]] &gt; p[i]) cnt--;
</span></span><span style="display:flex;"><span>		son[sta[cnt]][1] = i, son[i][0] = sta[cnt + 1];
</span></span><span style="display:flex;"><span>		sta[++cnt] = i, sta[cnt + 1] = 0;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	var res1 = 0, res2 = 0;
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;text-decoration:underline">for</span> (var i = 1; i &lt;= n; ++i)
</span></span><span style="display:flex;"><span>		res1 ^= i * (son[i][0] + 1), res2 ^= i * (son[i][1] + 1);
</span></span><span style="display:flex;"><span>	printf(<span style="color:#666;font-style:italic">&#34;%lld %lld</span><span style="color:#666;font-style:italic">\n</span><span style="color:#666;font-style:italic">&#34;</span>, res1, res2);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="拉格朗日插值">
  拉格朗日插值
  <a class="heading-link" href="#%e6%8b%89%e6%a0%bc%e6%9c%97%e6%97%a5%e6%8f%92%e5%80%bc">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">Point</span> {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> x, y;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">Lagrange</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, Point *point, <span style="font-weight:bold;text-decoration:underline">int</span> x) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> res = 0;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> u = 1, d = 1;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> j = 1; j &lt;= n; ++j) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (i == j) <span style="font-weight:bold;text-decoration:underline">continue</span>;
</span></span><span style="display:flex;"><span>      u = mul(u, add(x, MOD - point[j].x));
</span></span><span style="display:flex;"><span>      d = mul(d, add(point[i].x, MOD - point[j].x));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    res = add(res, mul(point[i].y, mul(u, inv(d))));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="回滚莫队">
  回滚莫队
  <a class="heading-link" href="#%e5%9b%9e%e6%bb%9a%e8%8e%ab%e9%98%9f">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>给定一个序列，多次询问一段区间 $[l,r]$，求区间中<strong>相同的数的最远间隔距离</strong>。</p>
<p>序列中两个元素的<strong>间隔距离</strong>指的是<strong>两个元素下标差的绝对值</strong>。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">Query</span> {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> id, l, r;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> n, v[N];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> len, val[N];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> m, cnt;
</span></span><span style="display:flex;"><span>Query query[N];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> res[N];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> in[N], mxpos[N];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> lshow[N], rshow[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">beMax</span>(<span style="font-weight:bold;text-decoration:underline">int</span> &amp;a, <span style="font-weight:bold;text-decoration:underline">int</span> b) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">if</span> (b &gt; a) a = b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">bool</span> <span style="color:#666;font-weight:bold;font-style:italic">camp</span>(Query a, Query b) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">if</span> (in[a.l] == in[b.l]) <span style="font-weight:bold;text-decoration:underline">return</span> a.r &lt; b.r;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">return</span> a.l &lt; b.l;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">Solve</span>() {
</span></span><span style="display:flex;"><span>  n = read();
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) v[i] = read();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) val[++len] = v[i];
</span></span><span style="display:flex;"><span>  sort(val + 1, val + n + 1);
</span></span><span style="display:flex;"><span>  len = unique(val + 1, val + len + 1) - val - 1;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i)
</span></span><span style="display:flex;"><span>    v[i] = upper_bound(val + 1, val + len + 1, v[i]) - val - 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> size = 500;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) in[i] = i / size + 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  m = read();
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= m; ++i) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> l = read(), r = read();
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (in[l] == in[r]) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> tres = 0;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> j = l; j &lt;= r; ++j) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">int</span> &amp;p = lshow[v[j]];
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">if</span> (!p) p = j;
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">else</span> beMax(tres, j - p);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      res[i] = tres;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> j = l; j &lt;= r; ++j) lshow[v[j]] = 0;
</span></span><span style="display:flex;"><span>    } <span style="font-weight:bold;text-decoration:underline">else</span> query[++cnt] = (Query) {i, l, r};
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  sort(query + 1, query + cnt + 1, camp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= cnt; ++i)
</span></span><span style="display:flex;"><span>    beMax(mxpos[in[query[i].l]], query[i].l);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> totres = 0, totl = 0, totr = 0;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= cnt; ++i) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (in[query[i].l] != in[query[i - 1].l]) {
</span></span><span style="display:flex;"><span>      memset(lshow, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(lshow));
</span></span><span style="display:flex;"><span>      memset(rshow, 0, <span style="font-weight:bold;text-decoration:underline">sizeof</span>(rshow));
</span></span><span style="display:flex;"><span>      totres = 0;
</span></span><span style="display:flex;"><span>      totl = mxpos[in[query[i].l]], totr = totl - 1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">while</span> (totr &lt; query[i].r) {
</span></span><span style="display:flex;"><span>      totr++;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> &amp;p = lshow[v[totr]];
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (!p) p = totr;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">else</span> beMax(totres, totr - p);
</span></span><span style="display:flex;"><span>      rshow[v[totr]] = totr;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> tmpres = totres, tmpl = totl;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">while</span> (tmpl &gt; query[i].l) {
</span></span><span style="display:flex;"><span>      tmpl--;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> &amp;p = rshow[v[tmpl]];
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (!p) p = tmpl;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">else</span> beMax(tmpres, p - tmpl);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    res[query[i].id] = tmpres;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= m; ++i)
</span></span><span style="display:flex;"><span>    printf(<span style="color:#666;font-style:italic">&#34;%d</span><span style="color:#666;font-style:italic">\n</span><span style="color:#666;font-style:italic">&#34;</span>, res[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="cdq-分治三位偏序">
  CDQ 分治/三位偏序
  <a class="heading-link" href="#cdq-%e5%88%86%e6%b2%bb%e4%b8%89%e4%bd%8d%e5%81%8f%e5%ba%8f">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">Num</span> {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> id, a, b, c;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">bool</span> <span style="font-weight:bold;text-decoration:underline">operator</span> &lt; (Num t) { 
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (a == t.a) {
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">if</span> (b == t.b) <span style="font-weight:bold;text-decoration:underline">return</span> c &lt; t.c;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">return</span> b &lt; t.b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> a &lt; t.a;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">bool</span> <span style="font-weight:bold;text-decoration:underline">operator</span> == (Num t) { 
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> a == t.a &amp;&amp; b == t.b &amp;&amp; c == t.c; 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> n, k, cnt;
</span></span><span style="display:flex;"><span>Num all[N], num[N], tmp[N];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> tree[K];
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> belong[N], f[N], have[N], res[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">solve</span>() {
</span></span><span style="display:flex;"><span>  scanf(<span style="color:#666;font-style:italic">&#34;%d%d&#34;</span>, &amp;n, &amp;k);
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) 
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#666;font-style:italic">&#34;%d%d%d&#34;</span>, &amp;all[i].a, &amp;all[i].b, &amp;all[i].c);
</span></span><span style="display:flex;"><span>  sort(all + 1, all + n + 1);
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (!(all[i] == num[cnt])) num[++cnt] = all[i];
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">if</span> (all[i] == num[cnt]) belong[i] = cnt, have[cnt]++;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= cnt; ++i) num[i].id = i;
</span></span><span style="display:flex;"><span>  cdq(1, cnt);
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= cnt; ++i) res[f[i] + have[i] - 1] += have[i];
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 0; i &lt; n; ++i) printf(<span style="color:#666;font-style:italic">&#34;%d</span><span style="color:#666;font-style:italic">\n</span><span style="color:#666;font-style:italic">&#34;</span>, res[i]);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">modify</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t, <span style="font-weight:bold;text-decoration:underline">int</span> v) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = t; i &lt;= k; i += i &amp; -i)
</span></span><span style="display:flex;"><span>    tree[i] += v;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">query</span>(<span style="font-weight:bold;text-decoration:underline">int</span> t) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> res = 0;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = t; i; i -= i &amp; -i) res += tree[i];
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">cdq</span>(<span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">if</span> (l == r) <span style="font-weight:bold;text-decoration:underline">return</span> ;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> mid = (l + r) &gt;&gt; 1;
</span></span><span style="display:flex;"><span>  cdq(l, mid), cdq(mid + 1, r);
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">int</span> i = l, j = mid + 1, k = l;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">while</span> (i &lt;= mid || j &lt;= r) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">while</span> (i &lt;= mid &amp;&amp; (j &gt; r || num[i].b &lt;= num[j].b))
</span></span><span style="display:flex;"><span>      tmp[k++] = num[i], modify(num[i].c, have[num[i].id]), i++;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">while</span> (j &lt;= r &amp;&amp; (i &gt; mid || num[i].b &gt; num[j].b)) 
</span></span><span style="display:flex;"><span>      tmp[k++] = num[j], f[num[j].id] += query(num[j].c), j++;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> t = l; t &lt;= mid; ++t) modify(num[t].c, -have[num[t].id]);
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> t = l; t &lt;= r; ++t) num[t] = tmp[t];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="线段树合并">
  线段树合并
  <a class="heading-link" href="#%e7%ba%bf%e6%ae%b5%e6%a0%91%e5%90%88%e5%b9%b6">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">void</span> SegTree::Merge(<span style="font-weight:bold;text-decoration:underline">int</span> &amp;t, <span style="font-weight:bold;text-decoration:underline">int</span> s, <span style="font-weight:bold;text-decoration:underline">int</span> l, <span style="font-weight:bold;text-decoration:underline">int</span> r) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">if</span> (!s) <span style="font-weight:bold;text-decoration:underline">return</span> ;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">if</span> (!t) t = s;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">else</span> <span style="color:#666;font-weight:bold;font-style:italic">if</span> (l == r) num[t] += num[s];
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">else</span> {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> mid = (l + r) &gt;&gt; 1;
</span></span><span style="display:flex;"><span>    Merge(lson[t], lson[s], l, mid);
</span></span><span style="display:flex;"><span>    Merge(rson[t], rson[s], mid + 1, r);
</span></span><span style="display:flex;"><span>    num[t] = max(num[lson[t]], num[rson[t]]);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="二维凸包">
  二维凸包
  <a class="heading-link" href="#%e4%ba%8c%e7%bb%b4%e5%87%b8%e5%8c%85">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">const</span> <span style="font-weight:bold;text-decoration:underline">int</span> N = 1e5 + 1;
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">const</span> let EPS = 1e-8;
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">const</span> let Pi = acos(-1.0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">struct</span> <span style="color:#666;font-weight:bold;font-style:italic">Point</span> {
</span></span><span style="display:flex;"><span>  let x, y;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">friend</span> Point <span style="font-weight:bold;text-decoration:underline">operator</span> - (Point a, Point b) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> (Point) {a.x - b.x, a.y - b.y};
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">friend</span> let <span style="color:#666;font-weight:bold;font-style:italic">Cdot</span>(Point a, Point b) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> a.x * b.x + a.y * b.y;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">friend</span> let <span style="color:#666;font-weight:bold;font-style:italic">Times</span>(Point a, Point b) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> a.x * b.y - a.y * b.x; 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  let <span style="color:#666;font-weight:bold;font-style:italic">Dist</span>() {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> sqrt(x * x + y * y);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  Point <span style="color:#666;font-weight:bold;font-style:italic">Rotate</span>(let k) {
</span></span><span style="display:flex;"><span>    Point kp = (Point) {sin(k), cos(k)};
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">return</span> (Point) {Times(*<span style="font-weight:bold;text-decoration:underline">this</span>, kp), Cdot(*<span style="font-weight:bold;text-decoration:underline">this</span>, kp)};
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">typedef</span> Point Vec;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> <span style="color:#666;font-weight:bold;font-style:italic">sign</span>(let x) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">if</span> (x &gt; EPS) <span style="font-weight:bold;text-decoration:underline">return</span> 1;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">if</span> (x &lt; -EPS) <span style="font-weight:bold;text-decoration:underline">return</span> -1;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">bool</span> <span style="color:#666;font-weight:bold;font-style:italic">CampByXY</span>(Point a, Point b) {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">if</span> (sign(a.x - b.x) == 0) <span style="font-weight:bold;text-decoration:underline">return</span> sign(a.y - b.y) &lt; 0;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">return</span> sign(a.x - b.x) &lt; 0;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">class</span> <span style="color:#666;font-weight:bold;font-style:italic">Geometry</span> {
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">protected</span>:
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">int</span> cnt, sta[N];
</span></span><span style="display:flex;"><span>    Point tmp[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">public</span>:
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> GetConvexHull(<span style="font-weight:bold;text-decoration:underline">int</span> n, Point *point, <span style="font-weight:bold;text-decoration:underline">int</span> &amp;len, Point *res) {
</span></span><span style="display:flex;"><span>      sort(point + 1, point + n + 1, CampByXY);
</span></span><span style="display:flex;"><span>      sta[cnt = 1] = 1;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 2; i &lt;= n; ++i) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">while</span> (cnt &gt; 1 &amp;&amp; Times(
</span></span><span style="display:flex;"><span>              point[sta[cnt]] - point[sta[cnt - 1]],
</span></span><span style="display:flex;"><span>              point[i] - point[sta[cnt]]
</span></span><span style="display:flex;"><span>              ) &lt; 0) cnt--;
</span></span><span style="display:flex;"><span>        sta[++cnt] = i;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">int</span> down_hull_cnt = cnt;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = n - 1; i &gt;= 1; --i) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold;text-decoration:underline">while</span> (cnt &gt; down_hull_cnt &amp;&amp; Times(
</span></span><span style="display:flex;"><span>              point[sta[cnt]] - point[sta[cnt - 1]],
</span></span><span style="display:flex;"><span>              point[i] - point[sta[cnt]]
</span></span><span style="display:flex;"><span>              ) &lt; 0) cnt--;
</span></span><span style="display:flex;"><span>        sta[++cnt] = i;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      len = cnt;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= len; ++i) 
</span></span><span style="display:flex;"><span>        res[i] = point[sta[i]];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">GetCH</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, Point *point, <span style="font-weight:bold;text-decoration:underline">int</span> &amp;len, Point *res) {
</span></span><span style="display:flex;"><span>      GetConvexHull(n, point, len, res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">SafeGetCH</span>(<span style="font-weight:bold;text-decoration:underline">int</span> n, Point *point, <span style="font-weight:bold;text-decoration:underline">int</span> &amp;len, Point *res) {
</span></span><span style="display:flex;"><span>      let angle = ((let) rand() / RAND_MAX) * Pi;
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) tmp[i] = point[i].Rotate(angle);
</span></span><span style="display:flex;"><span>      GetConvexHull(n, tmp, len, res);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i) res[i] = res[i].Rotate(-angle);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>} geometry;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">int</span> n, m;
</span></span><span style="display:flex;"><span>Point origin[N], hull[N];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">void</span> <span style="color:#666;font-weight:bold;font-style:italic">solve</span>() {
</span></span><span style="display:flex;"><span>  n = read();
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 1; i &lt;= n; ++i)
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#666;font-style:italic">&#34;%Lf%Lf&#34;</span>, &amp;origin[i].x, &amp;origin[i].y);
</span></span><span style="display:flex;"><span>  geometry.SafeGetCH(n, origin, m, hull);
</span></span><span style="display:flex;"><span>  let res = (hull[1] - hull[m]).Dist();
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold;text-decoration:underline">for</span> (<span style="font-weight:bold;text-decoration:underline">int</span> i = 2; i &lt;= m; ++i)
</span></span><span style="display:flex;"><span>    res += (hull[i] - hull[i - 1]).Dist();
</span></span><span style="display:flex;"><span>  printf(<span style="color:#666;font-style:italic">&#34;%.2Lf</span><span style="color:#666;font-style:italic">\n</span><span style="color:#666;font-style:italic">&#34;</span>, res);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
      </div>

      <footer>
        


        
        
        
      </footer>
    </article>

    

    <h1 style="text-align: center;">赞助区</h1>
    <div style="display: flex; flex-wrap: wrap; ">
      <img src="https://ccviolett-1307804825.cos.ap-shanghai.myqcloud.com/img/202205142210866.png/w200" style="margin: 1rem"/>
      <img src="https://ccviolett-1307804825.cos.ap-shanghai.myqcloud.com/img/202205142210865.jpg/w200" style="margin: 1rem"/>
      <img src="https://ccviolett-1307804825.cos.ap-shanghai.myqcloud.com/img/202205142210864.png/w200" style="margin: 1rem"/>
      <p>如果觉得文章对你有帮助，可以给作者买杯咖啡。作者非常感谢你的支持，你的每一点点激励都是作者不断创作的动力。</p>
      <p>所有收到的赞助都将在<a href="/support">收到的赞助</a>里显示，你可以在支付时留下备注。</p>
    </div>

    
    
    

    <h1 style="text-align: center;">评论区</h1>
    <p>欢迎大家在下面多多评论：</p>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="vcomments"></div>
    <script>
        new Valine({
            el: '#vcomments',
            appId: 'pKI8zxDMRprnFwEiUfoQF3tV-gzGzoHsz',
            appKey: 'xy8f32RhY529hvUDA8Ih165N',
            avatar: 'mp'
        })
    </script>

  </section>

      </div>

      
  <footer class="footer">
    <section class="container">
      
        <p>愿你成为自己的太阳，无需借助别人的光。</br>博客接受大众投稿，联系QQ 3340751717。</p>
      
      
        ©
        
        2022
         罗潇阳 
      
      
         · 
        技术支持 <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
      
      
        
      
    </section>
  </footer>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4610306996952179" crossorigin="anonymous"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>



    </main>

    
      
      <script src="/js/coder.min.f453d26c79f010446cf0d9770197f77de32c07b7a5512d141a286247fe154a22.js" integrity="sha256-9FPSbHnwEERs8Nl3AZf3feMsB7elUS0UGihiR/4VSiI="></script>
    

    

    

    

    

    

    

    

    
  </body>
</html>
